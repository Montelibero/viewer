<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Stellar Transaction Viewer · eurmtl</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bulma -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
  <link id="common-css" rel="stylesheet" href="/common.css?3">
</head>
<body>
<section class="section">
  <div class="container">

    <div class="mb-4 is-flex is-justify-content-space-between is-align-items-center">
      <a class="button is-small is-light" href="/" data-i18n="back-home">На главную</a>
      <div class="buttons are-small" id="lang-switcher">
        <button class="button is-light" data-lang="ru">RU</button>
        <button class="button is-light" data-lang="en">EN</button>
        <button class="button is-light" data-lang="es">ES</button>
      </div>
    </div>

    <!-- Шапка -->
    <div class="box" id="tx-header-box">
      <div class="level is-mobile">
        <div class="level-left">
          <div>
            <p class="title is-5 box-title" data-i18n="header-title">Stellar Transaction</p>
            <p class="subtitle is-7" id="network-label" data-i18n="network-label">Mainnet · horizon.stellar.org</p>
          </div>
        </div>
        <div class="level-right">
          <span class="tag" id="status-label" data-i18n="status-loading">Загрузка…</span>
        </div>
      </div>

      <p class="is-size-7 mb-1"><strong data-i18n="hash-title">Хэш транзакции</strong></p>
      <p class="is-mono is-size-7" id="tx-hash">—</p>

      <div class="mt-2">
        <button class="button is-small is-light" id="copy-hash-btn" data-i18n="copy-hash">
          Скопировать хэш
        </button>
        <a class="button is-small is-link is-light" id="btn-scopuly" target="_blank" rel="noreferrer" data-i18n="link-scopuly">
          Scopuly
        </a>
        <a class="button is-small is-link is-light" id="btn-expert" target="_blank" rel="noreferrer" data-i18n="link-expert">
          Stellar Expert
        </a>
      </div>

      <div class="mt-3 is-size-7">
        <div><span data-i18n="ledger-label">Леджер</span>: <span id="ledger">—</span></div>
        <div><span data-i18n="created-label">Создана</span>: <span id="created-at">—</span></div>
        <div><span data-i18n="source-label">Источник</span>: <span class="is-mono" id="source-account">—</span></div>
        <div><span data-i18n="op-count-label">Операций</span>: <span id="op-count">—</span></div>
        <div><span data-i18n="fee-charged-label">Комиссия (фактическая)</span>: <span id="fee-charged">—</span></div>
      </div>
    </div>

    <!-- Ошибка -->
    <article class="message is-danger is-hidden" id="error-box">
      <div class="message-header">
        <p data-i18n="error-title">Ошибка</p>
      </div>
      <div class="message-body is-size-7" id="error-text">
        —
      </div>
    </article>

    <!-- Лоадер -->
    <progress class="progress is-small is-primary is-hidden"
              max="100" id="loader" data-i18n="loader-text">Загрузка</progress>

    <!-- Декодированные данные XDR (человеческий вид) -->
    <div class="box">
      <p class="title is-6 box-title" data-i18n="tx-data-title">Данные транзакции (из XDR)</p>

      <div class="is-size-7">
        <div><span data-i18n="seq-label">Sequence</span>: <span id="seq-num">—</span></div>
        <div><span data-i18n="memo-label">Memo</span>: <span id="memo">—</span></div>
        <div><span data-i18n="time-bounds-label">Временные границы</span>: <span id="time-bounds">—</span></div>
        <div><span data-i18n="base-fee-label">Base fee (из XDR)</span>: <span id="base-fee">—</span></div>
      </div>

      <hr>

      <p class="title is-7" data-i18n="operations-title">Операции</p>
      <div id="operations-list" class="is-size-7" data-i18n="operations-loading">
        Загрузка операций…
      </div>
    </div>

    <!-- Подписи -->
    <div class="box is-hidden" id="signatures-box">
      <p class="title is-6 box-title" data-i18n="signatures-title">Подписи</p>
      <div id="signatures-list" class="is-size-7">
        <span data-i18n="signatures-loading">Загрузка подписей…</span>
      </div>
    </div>

    <!-- Чистый JSON из XDR -->
    <div class="box">
      <p class="title is-6 box-title" data-i18n="json-title">Чистый JSON (decode TransactionEnvelope)</p>
      <p class="is-size-7 mb-2">
        <span data-i18n="json-desc">Это прямой результат декодирования XDR → JSON через</span>
        <code>@stellar/stellar-xdr-json</code>.
      </p>
      <pre><code id="json-body" class="is-mono">—</code></pre>
    </div>

    <!-- Сырой XDR -->
    <div class="box">
      <p class="title is-6 box-title" data-i18n="xdr-title">Сырой XDR (envelope_xdr)</p>
      <p class="is-size-7 mb-2" data-i18n="xdr-desc">
        На случай, если захочется проверить декодирование вручную.
      </p>
      <pre><code id="xdr-raw" class="is-mono">—</code></pre>
    </div>

  </div>
</section>

<script type="module">
  const commonBase = (() => {
    if (window.location.protocol === 'file:') return './common';
  const m = window.location.pathname.match(/^(.*\/site)\//);
  if (m) return `${m[1]}/common`;
  return '/common';
  })();
  document.getElementById('common-css').href = `${commonBase}.css?3`;
  const i18nBase = commonBase.replace(/common$/, 'i18n');
  const moduleBase = (() => {
    if (window.location.protocol === 'file:') return './';
    const m = window.location.pathname.match(/^(.*\/site)\//);
    if (m) return `${m[1]}/`;
    return '/';
  })();
  const {
    accountLink,
    createXdrOperationBox,
    formatStroopAmount,
    renderAccount,
    renderAsset
  } = await import(`${moduleBase}operation-view.js?3`);
  const { initI18n } = await import(`${i18nBase}.js?3`);

  const horizonBase = 'https://horizon.stellar.org';
  const langButtons = Array.from(document.querySelectorAll('#lang-switcher [data-lang]'));
  const i18n = await initI18n({ baseName: 'transaction' });
  const { t } = i18n;

  const statusEl = document.getElementById('status-label');
  const errorBox = document.getElementById('error-box');
  const errorText = document.getElementById('error-text');
  const loader = document.getElementById('loader');
  const operationsList = document.getElementById('operations-list');
  const signaturesBox = document.getElementById('signatures-box');
  const signaturesList = document.getElementById('signatures-list');

  let lastErrorKey = '';
  let lastErrorDetail = '';
  let statusState = 'loading';
  let loaderVisible = false;
  let txData = null;
  let decodedTxObj = null;
  let currentTxHash = null;
  let signaturesData = null;

  const base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  const base32Lookup = {};
  for(let i=0; i<base32Alphabet.length; i++) {
    base32Lookup[base32Alphabet[i]] = i;
  }

  function decodeBase32(input) {
    input = input.replace(/=+$/, '');
    let length = input.length;
    let leftover = (length * 5) % 8;

    let bits = 0;
    let value = 0;
    let output = new Uint8Array(Math.floor(length * 5 / 8));
    let index = 0;

    for (let i = 0; i < length; i++) {
      value = (value << 5) | base32Lookup[input[i]];
      bits += 5;
      if (bits >= 8) {
        output[index++] = (value >>> (bits - 8)) & 0xFF;
        bits -= 8;
      }
    }
    return output;
  }

  function getHintFromAddress(address) {
     try {
       const bytes = decodeBase32(address);
       if (bytes.length < 33) return null;
       const hintBytes = bytes.slice(29, 33);
       return Array.from(hintBytes).map(b => b.toString(16).padStart(2, '0')).join('');
     } catch (e) {
       console.error('Error decoding address hint', address, e);
       return null;
     }
  }

  function hexToBytes(hex) {
    if (!hex) return new Uint8Array(0);
    // Handle potential Base64 input just in case
    if (/^[0-9a-fA-F]+$/.test(hex)) {
        const bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return bytes;
    }
    try {
        const binString = atob(hex);
        return Uint8Array.from(binString, c => c.charCodeAt(0));
    } catch (e) {
        return new Uint8Array(0);
    }
  }

  function encodeBase32(data) {
    let output = '';
    let val = 0;
    let bits = 0;
    for (let i = 0; i < data.length; i++) {
        val = (val << 8) | data[i];
        bits += 8;
        while (bits >= 5) {
            output += base32Alphabet[(val >>> (bits - 5)) & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        output += base32Alphabet[(val << (5 - bits)) & 31];
    }
    return output;
  }

  function getMaskedHint(hexHint) {
      try {
          const hintBytes = hexToBytes(hexHint);
          if (hintBytes.length !== 4) return hexHint;

          const bytes = new Uint8Array(35);
          bytes[0] = 48; // Version byte (logical for G)
          bytes.set(hintBytes, 29); // Set last 4 bytes of key

          const fullStr = encodeBase32(bytes);

          // Format: G + 46 dashes + 5 chars + 4 dashes
          return 'G' +
                 '-'.repeat(46) +
                 fullStr.slice(47, 52) +
                 '-'.repeat(4);
      } catch (e) {
          console.error(e);
          return hexHint;
      }
  }

  async function loadSignatures(txData, decodedEnvelope, decodedTxBody) {
    signaturesBox.classList.remove('is-hidden');
    signaturesList.innerHTML = `<span class="loader"></span> ${t('signatures-loading')}`;
    signaturesData = null;

    try {
        let sigs = [];
        if (decodedEnvelope.signatures) sigs = decodedEnvelope.signatures;
        else if (decodedEnvelope.v1 && decodedEnvelope.v1.signatures) sigs = decodedEnvelope.v1.signatures;
        else if (decodedEnvelope.tx && decodedEnvelope.tx.signatures) sigs = decodedEnvelope.tx.signatures;
        else if (decodedEnvelope.feeBump && decodedEnvelope.feeBump.signatures) sigs = decodedEnvelope.feeBump.signatures;

        if (!sigs || !sigs.length) {
            signaturesList.textContent = '—';
            return;
        }

        const accountsToCheck = new Set();
        if (txData.source_account) accountsToCheck.add(txData.source_account);
        if (txData.fee_account) accountsToCheck.add(txData.fee_account);

        if (decodedTxBody && decodedTxBody.operations) {
            decodedTxBody.operations.forEach(op => {
               const acc = op.sourceAccount || op.source_account;
               if (typeof acc === 'string') accountsToCheck.add(acc);
               else if (acc && acc.ed25519) accountsToCheck.add(acc.ed25519);
            });
        }

        const signerMap = {};
        const accounts = Array.from(accountsToCheck);

        await Promise.all(accounts.map(async (accId) => {
            try {
                const res = await fetch(`${horizonBase}/accounts/${accId}`);
                if (res.ok) {
                    const accData = await res.json();
                    if (accData.signers) {
                        accData.signers.forEach(signer => {
                           let hint = null;
                           if (signer.key.startsWith('G')) {
                               hint = getHintFromAddress(signer.key);
                           } else if (signer.type === 'sha256_hash' || signer.type === 'preauth_tx') {
                               // HashX / PreAuthTx keys are also encoded as StrKeys (X..., T...)
                               // decodeBase32 handles them correctly.
                               hint = getHintFromAddress(signer.key);
                           }

                           if (hint) {
                               signerMap[hint] = {
                                   address: signer.key,
                                   weight: signer.weight,
                                   type: signer.type
                               };
                           }
                        });
                    }
                }
            } catch (e) {
                console.warn('Failed to fetch account', accId, e);
            }
        }));

        signaturesData = { sigs, signerMap };
        renderSignatures();

    } catch (e) {
        console.error('Error loading signatures', e);
        signaturesList.textContent = t('error-unknown');
    }
  }

  function renderSignatures() {
    if (!signaturesData) return;
    const { sigs, signerMap } = signaturesData;
    signaturesList.innerHTML = '';

    if (!sigs.length) {
       signaturesList.textContent = '—';
       return;
    }

    const ul = document.createElement('ul');

    sigs.forEach(sig => {
        const hint = sig.hint;
        const info = signerMap[hint];

        const li = document.createElement('li');
        li.className = 'mb-1 is-flex is-align-items-center is-flex-wrap-wrap';

        if (info) {
            const a = document.createElement('a');
            a.href = accountLink(info.address);
            a.className = 'is-mono mr-2';
            a.style.wordBreak = 'break-all'; // Ensure long addresses wrap
            a.textContent = info.address;
            li.appendChild(a);
        } else {
            const hintSpan = document.createElement('span');
            hintSpan.className = 'is-mono mr-2 has-text-grey';
            hintSpan.style.wordBreak = 'break-all';
            hintSpan.textContent = getMaskedHint(hint);
            hintSpan.title = `Hex Hint: ${hint}`;
            li.appendChild(hintSpan);
        }

        ul.appendChild(li);
    });

    signaturesList.appendChild(ul);
  }

  function showLoading(on) {
    loader.textContent = t('loader-text');
    loaderVisible = on;
    loader.classList.toggle('is-hidden', !on);
  }

  function setStatus(state) {
    statusState = state;
    statusEl.classList.remove('is-danger', 'is-success', 'is-info');
    let key = 'status-loading';
    if (state === 'success') {
      statusEl.classList.add('is-success');
      key = 'status-success';
    } else if (state === 'failed') {
      statusEl.classList.add('is-danger');
      key = 'status-failed';
    } else if (state === 'error') {
      statusEl.classList.add('is-danger');
      key = 'status-error';
    } else {
      statusEl.classList.add('is-info');
    }
    statusEl.textContent = t(key);
  }

  function showError(messageKey, { detail = '' } = {}) {
    lastErrorKey = messageKey || '';
    lastErrorDetail = detail || '';
    const base = messageKey ? t(messageKey) : '';
    const msg = detail ? `${base ? base + ': ' : ''}${detail}` : base;
    errorText.textContent = msg || detail || '';
    errorBox.classList.remove('is-hidden');
    setStatus('error');
  }

  function setExternalLinks(hash) {
    const scopulyBtn = document.getElementById('btn-scopuly');
    const expertBtn = document.getElementById('btn-expert');
    if (hash) {
      scopulyBtn.href = `https://scopuly.com/transaction/${hash}`;
      expertBtn.href = `https://stellar.expert/explorer/public/tx/${hash}`;
      scopulyBtn.classList.remove('is-static');
      expertBtn.classList.remove('is-static');
    } else {
      scopulyBtn.href = '#';
      expertBtn.href = '#';
      scopulyBtn.classList.add('is-static');
      expertBtn.classList.add('is-static');
    }
  }

  function clearError() {
    errorBox.classList.add('is-hidden');
  }

  function getTxHashFromUrl() {
    const parts = window.location.pathname.split('/').filter(Boolean);
    const idx = parts.indexOf('transaction');
    if (idx >= 0 && parts.length > idx + 1) {
      return parts[idx + 1];
    }
    // старый вариант /transaction/<hash> без префикса
    if (parts[0] === 'transaction' && parts[1]) {
      return parts[1];
    }
    if (window.location.protocol === 'file:' || location.hostname === 'localhost') {
      return '1ef4254c62007a14738cafad114861c045bc510ad8a7f92c13b1d21ff846c45b';
    }
    return null;
  }

  function describeMemo(memo) {
    if (!memo) return t('memo-none');
    const keys = Object.keys(memo);
    if (!keys.length) return t('memo-none');
    const tkey = keys[0];
    const v = memo[tkey];
    if (tkey === 'text') return t('memo-text').replace('{text}', v);
    if (tkey === 'id') return t('memo-id').replace('{id}', v);
    if (tkey === 'hash') return t('memo-hash').replace('{hash}', v);
    if (tkey === 'ret_hash' || tkey === 'return') return t('memo-return').replace('{hash}', v);
    return `${tkey}: ${JSON.stringify(v)}`;
  }

  function describeTimeBounds(cond) {
    if (!cond || !cond.time) return t('time-bounds-none');
    const { min_time, max_time } = cond.time;
    if ((!min_time || min_time === '0') && (!max_time || max_time === '0')) {
      return t('time-bounds-none');
    }
    return `${t('time-bounds-min')}: ${min_time || '0'}, ${t('time-bounds-max')}: ${max_time || '0'}`;
  }

  function extractTxObject(decoded) {
    // пробуем разные популярные формы
    if (decoded.tx && decoded.tx.tx) return decoded.tx.tx;
    if (decoded.v1 && decoded.v1.tx) return decoded.v1.tx;
    if (decoded.tx) return decoded.tx;
    return decoded;
  }

  function renderOperations(tx) {
    const container = document.getElementById('operations-list');
    container.innerHTML = '';

    const ops = Array.isArray(tx.operations) ? tx.operations : [];
    if (!ops.length) {
      container.textContent = t('operations-empty');
      return;
    }

    ops.forEach((op, index) => {
      const box = createXdrOperationBox(op, index, tx.source_account, { txSuccessful: tx.successful });
      container.appendChild(box);
    });
  }

  async function main() {
    const txHash = getTxHashFromUrl();
    const txHashEl = document.getElementById('tx-hash');
    const ledgerEl = document.getElementById('ledger');
    const createdAtEl = document.getElementById('created-at');
    const sourceAccountEl = document.getElementById('source-account');
    const opCountEl = document.getElementById('op-count');
    const feeChargedEl = document.getElementById('fee-charged');
    const seqEl = document.getElementById('seq-num');
    const memoEl = document.getElementById('memo');
    const timeBoundsEl = document.getElementById('time-bounds');
    const baseFeeEl = document.getElementById('base-fee');
    const jsonBodyEl = document.getElementById('json-body');
    const xdrRawEl = document.getElementById('xdr-raw');

    if (!txHash) {
      showError('error-no-hash');
      return;
    }

    currentTxHash = txHash;
    txHashEl.textContent = txHash;
    setExternalLinks(txHash);

    document.getElementById('copy-hash-btn').addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(txHash);
        const btn = document.getElementById('copy-hash-btn');
        const old = btn.textContent;
        btn.textContent = t('copy-success');
        setTimeout(() => (btn.textContent = old), 1500);
      } catch (e) {
        alert(t('copy-failed'));
      }
    });

    clearError();
    setStatus('loading');
    showLoading(true);

    try {
      // 1) Тянем транзакцию из Horizon
      const res = await fetch(`${horizonBase}/transactions/${encodeURIComponent(txHash)}`);
      if (!res.ok) {
        let detail = `Horizon error ${res.status}`;
        try {
          const err = await res.json();
          if (err?.detail) detail = err.detail;
        } catch (_) {}
        throw new Error(detail);
      }
      const tx = await res.json();
      txData = tx;

      const successful = tx.successful;
      setStatus(successful ? 'success' : 'failed');
      const headerBox = document.getElementById('tx-header-box');
      if (headerBox) {
        if (successful) headerBox.classList.remove('is-failed');
        else headerBox.classList.add('is-failed');
      }

      ledgerEl.textContent = tx.ledger ?? '—';
      createdAtEl.textContent = tx.created_at ?? '—';
      const srcLink = accountLink(tx.source_account);
      sourceAccountEl.innerHTML = srcLink
        ? `<a class="is-mono" href="${srcLink}">${tx.source_account}</a>`
        : (tx.source_account ?? '—');
      opCountEl.textContent = tx.operation_count ?? '—';
      feeChargedEl.textContent = `${formatStroopAmount(tx.fee_charged)} XLM`;

      setExternalLinks(txHash);

      const envelopeXdr = tx.envelope_xdr;
      if (!envelopeXdr) {
        throw new Error(t('error-no-envelope'));
      }

      // 2) Показываем сырой XDR
      xdrRawEl.textContent = envelopeXdr;

      // 3) Подключаем stellar-xdr-json и декодируем
      const mod = await import('https://esm.sh/@stellar/stellar-xdr-json');
      const initFn = mod.default || mod.init;
      if (typeof initFn === 'function') {
        await initFn();
      }
      const decodeFn = mod.decode;
      if (typeof decodeFn !== 'function') {
        throw new Error(t('error-decode'));
      }

      const decoded = decodeFn('TransactionEnvelope', envelopeXdr.trim());
      let decodedObj;
      if (typeof decoded === 'string') {
        try {
          decodedObj = JSON.parse(decoded);
        } catch (_) {
          decodedObj = { raw: decoded };
        }
      } else {
        decodedObj = decoded;
      }

      // 4) JSON-блок
      jsonBodyEl.textContent = JSON.stringify(decodedObj, null, 2);

      // 5) Человекочитаемый вывод
      const txObj = extractTxObject(decodedObj);
      decodedTxObj = txObj;
      seqEl.textContent = txObj.seq_num ?? '—';
      memoEl.textContent = describeMemo(txObj.memo);
      timeBoundsEl.textContent = describeTimeBounds(txObj.cond);
      baseFeeEl.textContent = `${txObj.fee ?? '—'} ${t('base-fee-suffix')}`; // это base fee

      renderOperations(txObj);
      loadSignatures(txData, decodedObj, txObj);
    } catch (e) {
      console.error(e);
      showError('error-load-tx', { detail: e.message || t('error-unknown') });
    } finally {
      showLoading(false);
    }
  }

  // запуск
  main();

  function setActiveLangButton(lang) {
    langButtons.forEach((btn) => {
      const isActive = btn.dataset.lang === lang;
      btn.classList.toggle('is-primary', isActive);
      btn.classList.toggle('is-light', !isActive);
    });
  }

  function reapplyLanguage() {
    if (currentTxHash) document.getElementById('tx-hash').textContent = currentTxHash;
    setExternalLinks(currentTxHash);
    if (txData) {
      const { ledger, created_at, source_account, operation_count, fee_charged, successful } = txData;
      document.getElementById('ledger').textContent = ledger ?? '—';
      document.getElementById('created-at').textContent = created_at ?? '—';
      const srcLink = accountLink(source_account);
      document.getElementById('source-account').innerHTML = srcLink
        ? `<a class="is-mono" href="${srcLink}">${source_account}</a>`
        : (source_account ?? '—');
      document.getElementById('op-count').textContent = operation_count ?? '—';
      document.getElementById('fee-charged').textContent = `${formatStroopAmount(fee_charged)} XLM`;
      setStatus(successful ? 'success' : 'failed');
      const headerBox = document.getElementById('tx-header-box');
      if (headerBox) {
        if (successful) headerBox.classList.remove('is-failed');
        else headerBox.classList.add('is-failed');
      }
    }
    if (decodedTxObj) {
      document.getElementById('seq-num').textContent = decodedTxObj.seq_num ?? '—';
      document.getElementById('memo').textContent = describeMemo(decodedTxObj.memo);
      document.getElementById('time-bounds').textContent = describeTimeBounds(decodedTxObj.cond);
      document.getElementById('base-fee').textContent = `${decodedTxObj.fee ?? '—'} ${t('base-fee-suffix')}`;
      renderOperations(decodedTxObj);
    } else {
      operationsList.textContent = t('operations-loading');
    }
    renderSignatures();
    const errorVisible = !errorBox.classList.contains('is-hidden');
    if (errorVisible) {
      showError(lastErrorKey, { detail: lastErrorDetail });
    }
    showLoading(loaderVisible);
    setActiveLangButton(i18n.lang());
  }

  setActiveLangButton(i18n.lang());

  langButtons.forEach((btn) => {
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      const nextLang = btn.dataset.lang;
      await i18n.setLang(nextLang);
      reapplyLanguage();
    });
  });
</script>

</body>
</html>
